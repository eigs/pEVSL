#include "pevsl_int.h"

/**
 * @file lspolapprox.c
 * @brief Least squares polynomial approximation to a matrix function
 * */
/**
 * Define a struct for L-S polynomial approximation to a matrix function
 */
typedef struct _LSPol_Data {
  int N, n;            /**< global/local sizes and nfirst */
  int nfirst;
  int max_deg;         /**< max degree set by user */
  int deg;             /**< actual degree of the polynomial */
  double intv[2];      /**< spectrum bounds of the matrix */
  double cc, dd;       /**< center and half-width */
  double tol;          /**< approx. tolerance */
  double *mu;          /**< polyno. coeff */
  pevsl_Parvec wk[3];  /**< working space for applying */
  pevsl_Matvec mv;     /**< matvec function and data */
  MPI_Comm comm;       /**< communicator */
} LSPol_Data;

/** ----------------------------------------------------------------------
 *    @brief
 *    Evalutes ffun at the xi's.
 *    Assumes a transformation of original inetrval [a b] into [-1, 1] so:
 *    the xi's are between -1 and 1
 *
 *    @param[in] c Value to increase xi's by
 *    @param[in] h Value to scale xi's by
 *    @param[in] *xi Points for which to evaluate ffun at
 *    @param[in] npts Number of points in xi to evaluate
 *    @param[in] ffun Function to evaluate
 *
 *    @param[out] yi ffun evaluated at xi's
 *----------------------------------------------------------------------*/
static inline int apfun(const double c, const double h, const double *const xi,
                        double (*ffun)(double), const int npts, double *yi) {
  int i = 0;
  for (i = 0; i < npts; i++) {
    yi[i] = ffun(c + h * xi[i]);
  }

  return 0;
}

/** ----------------------------------------------------------------------
 *    @brief
 *    Finds the least-square polynomial approximation to function ffun
 *    in interval given by intv
 *
 *    @param[in] ffun Function to generate an approximation for
 *
 *    @param[in,out] pol polparams struct
 *      Contains: cc = (a + b) / 2
 *                dd = (b - a) / 2
 *                mu = coefficients
 *                max_deg = number of coefficients
 *----------------------------------------------------------------------*/
int pEVSL_FindLSPol(double (*ffun)(double), LSPol_Data *pol) {
  const double a = pol->intv[0];
  const double b = pol->intv[1];
  pol->cc = (a + b) / 2;
  pol->dd = (b - a) / 2;
  /*------------------------- Number of points for Gauss-Chebyshev integration */
  int maxDeg = pol->max_deg;
  const int npts = maxDeg * 4;
  double *theti;
  PEVSL_MALLOC(theti, npts, double);

  int i = 0;
  for (i = 0; i < npts * 2; i += 2) {
    theti[i / 2] = (i + 1) * (PI / (2 * npts));
  }

  double *xi;
  PEVSL_MALLOC(xi, npts, double);

  for (i = 0; i < npts; i++) {
    xi[i] = cos(theti[i]);
  }

  double *gi;
  PEVSL_MALLOC(gi, npts, double);
  apfun(pol->cc, pol->dd, xi, ffun, npts, gi);
  PEVSL_FREE(xi);

  /* ----------------------- Degree loop
   * ----------------------- Each coefficient generated by gauss-Chebyshev quadature */
  const int ptsNrm = 50 * maxDeg;  // Number of points for norm infinity
  PEVSL_MALLOC(xi, ptsNrm, double);
  linspace(-1, 1, ptsNrm, xi);

  /* Compute f(x) once */
  double *yx;
  PEVSL_MALLOC(yx, ptsNrm, double);
  apfun(pol->cc, pol->dd, xi, ffun, ptsNrm, yx);

  double *yi;
  PEVSL_MALLOC(yi, npts, double);

  double *ya;
  PEVSL_MALLOC(ya, ptsNrm, double);

  double na;

  int k = 0;
  const double t1 = 1.0 / npts;
  const double t2 = 2.0 / npts;

  /* degree loop */
  for (k = 0; k < maxDeg; k++) {
    for (i = 0; i < npts; i++) {
      yi[i] = cos(k * theti[i]);
    }
    const double t = k == 0 ? t1 : t2;
    double sum = 0;
    for (i = 0; i < npts; i++) {
      sum += yi[i] * gi[i];
    }
    pol->mu[k] = t * sum;
    chebxPltd(k, pol->mu, ptsNrm, xi, ya);
    double nrm = 0;
    for (i = 0; i < ptsNrm; i++) {
      na = (ya[i] - yx[i]) / yx[i];
      nrm += fabs(na);
    }
    if (nrm < pol->tol) {
      k++;
      break;
    }
  }

  /* mu is of size k, so deg = k - 1 */
  pol->deg = k - 1;

  PEVSL_FREE(xi);
  PEVSL_FREE(yi);
  PEVSL_FREE(ya);
  PEVSL_FREE(yx);
  PEVSL_FREE(theti);
  PEVSL_FREE(gi);

  return 0;
}

/**
 *  @file lspolapprox.c
 *  @brief L-S Polynomial approximation routines
 */

/** @brief Reciprocal */
double rec(const double a) { return 1.0 / a; }

/** @brief Inverse square root */
double isqrt(const double a) { return 1.0 / sqrt(a); }

/** @brief
 * Initalize LSPol_Data: use L-S polynomial to approximate a function 'ffun'
 * @param[in] max_deg max degree
 * @param[in] tol tolerance
 * @param[in] lmin left bound of interval of desired eigenvalue
 * @param[in] lmax right bound of interval of desired eigenvalue
 * @param[in] B csr matrix
 * @param[in] ffun function to approximate
 * @param[in,out] vdata data output
 */
void pEVSL_SetupLSPol(int max_deg, double tol, double lmin, double lmax,
                      pevsl_Parcsr *B, double (*ffun)(double), void **vdata) {

  LSPol_Data *data;
  PEVSL_MALLOC(data, 1, LSPol_Data);

  data->N = B->ncol_global;
  data->n = B->ncol_local;
  data->nfirst = B->first_col;
  data->max_deg = max_deg;
  data->intv[0] = lmin;
  data->intv[1] = lmax;
  data->tol = tol;
  PEVSL_CALLOC(data->mu, max_deg, double);
  pEVSL_ParvecCreate(B->ncol_global, B->ncol_local, B->first_col, B->comm, &data->wk[0]);
  pEVSL_ParvecCreate(B->ncol_global, B->ncol_local, B->first_col, B->comm, &data->wk[1]);
  pEVSL_ParvecCreate(B->ncol_global, B->ncol_local, B->first_col, B->comm, &data->wk[2]);
  data->mv.func = pEVSL_ParcsrMatvec0;
  data->mv.data = (void *) B;
  data->comm = B->comm;

  /* determine degree and compute poly coeff */
  pEVSL_FindLSPol(ffun, data);

  *vdata = (void *) data;
}

/** @brief
 * Initialize the member of LSPol_Data struct for solving B^{-1}
 * @param[in] max_deg max degree
 * @param[in] tol tolerance
 * @param[in] lmin left bound of interval of desired eigenvalue
 * @param[in] lmax right bound of interval of desired eigenvalue
 * @param[in] B csr matrix
 * @param[in,out] vdata data output
 */
void pEVSL_SetupLSPolRec(int max_deg, double tol, double lmin, double lmax,
                         pevsl_Parcsr *B, void **vdata) {
  pEVSL_SetupLSPol(max_deg, tol, lmin, lmax, B, rec, vdata);
}

/** @brief
 * Initialize the member of LSPol_Data struct for solving B^{-1/2}
 * @param[in] max_deg max degree
 * @param[in] tol tolerance
 * @param[in] lmin left bound of interval of desired eigenvalue
 * @param[in] lmax right bound of interval of desired eigenvalue
 * @param[in] B csr matrix
 * @param[in,out] vdata data output
 */
void pEVSL_SetupLSPolSqrt(int max_deg, double tol, double lmin, double lmax,
                          pevsl_Parcsr *B, void **vdata) {
  pEVSL_SetupLSPol(max_deg, tol, lmin, lmax, B, isqrt, vdata);
}


/** @brief
 * Computes y=P(A) v, where pn is a Cheb. polynomial expansion
 *
 * This explicitly calls matvec, so it can be useful for implementing
 * user-specific matrix-vector multiplication.
 *
 * @param[in] mu Coefficents of the cheb. polynomial (size m+1)
 * @param[in] cc cc member of pol struct
 * @param[in] dd dd member of pol struct
 * @param[in] m m member of pol struct
 * @param[in] v input vector
 *
 * @param[out] y = p(A)v
 *
 * @b Workspace
 * @param[in,out] w Work vector of length 3*n [allocate before call
 **/
static inline int pnav(double *mu, const int m, const double cc, const double dd,
                       pevsl_Matvec *mv, pevsl_Parvec *v, pevsl_Parvec *y, pevsl_Parvec *w) {
  /*-------------------- pointers to v_[k-1],v_[k], v_[k+1] from w */
  pevsl_Parvec *vk   = &w[0];
  pevsl_Parvec *vkp1 = &w[1];
  pevsl_Parvec *vkm1 = &w[2];
  /*-------------------- */
  int k;
  double t, s;
  pevsl_Parvec *tmp;
  const double t1 = 1.0 / dd;
  const double t2 = 2.0 / dd;
  /*-------------------- vk <- v; vkm1 <- zeros(n,1) */
  pEVSL_ParvecCopy(v, vk);
  /* pEVSL_ParvecSetZero(vkm1); */
  /*-------------------- special case: k == 0 */
  s = mu[0];
  pEVSL_ParvecCopy(vk, y);
  pEVSL_ParvecScal(y, s);
  /*-------------------- degree loop. k IS the degree */
  for (k = 1; k <= m; k++) {
    /*-------------------- y = mu[k]*Vk + y */
    t = k == 1 ? t1 : t2;
    /*-------------------- */
    s = mu[k];

    mv->func(vk->data, vkp1->data, mv->data);

    pEVSL_ParvecAxpy(-cc, vk, vkp1);
    pEVSL_ParvecScal(vkp1, t);
    if (k > 1) {
      pEVSL_ParvecAxpy(-1.0, vkm1, vkp1);
    }
    pEVSL_ParvecAxpy(s, vkp1, y);

    /*-------------------- next: rotate vectors via pointer exchange */
    tmp = vkm1;
    vkm1 = vk;
    vk = vkp1;
    vkp1 = tmp;
  }

  return 0;
}

/** @brief
 * Solve function for LSPol_Data
 * @param[in] db Input vector
 * @param[out] dx output vector
 */
void pEVSL_LSPolSol(double *db, double *dx, void *data) {
  LSPol_Data *pol = (LSPol_Data *) data;
  pevsl_Parvec b, x;
  int N = pol->N;
  int n = pol->n;
  int nfirst = pol->nfirst;
  MPI_Comm comm = pol->comm;
  /* wrap b and x into pevsl_Parvec */
  pEVSL_ParvecCreateShell(N, n, nfirst, comm, &b, db);
  pEVSL_ParvecCreateShell(N, n, nfirst, comm, &x, dx);

  pnav(pol->mu, pol->deg, pol->cc, pol->dd, &pol->mv, &b, &x, pol->wk);
}


/** @brief
 * Free the LSPol_Data struct
 */
void pEVSL_LSPolFree(void *vdata) {
  LSPol_Data *data = (LSPol_Data *) vdata;
  pEVSL_ParvecFree(data->wk);
  pEVSL_ParvecFree(data->wk + 1);
  pEVSL_ParvecFree(data->wk + 2);
  PEVSL_FREE(data->mu);
  PEVSL_FREE(data);
}

